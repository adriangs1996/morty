# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http`.


# source://protocol-http//lib/protocol/http/methods.rb#6
module Protocol; end

# source://protocol-http//lib/protocol/http/methods.rb#7
module Protocol::HTTP; end

# source://protocol-http//lib/protocol/http/body/readable.rb#9
module Protocol::HTTP::Body; end

# A body which buffers all it's contents.
#
# source://protocol-http//lib/protocol/http/body/buffered.rb#13
class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  # @return [Buffered] a new instance of Buffered
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#46
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  # A rewindable body wraps some other body. Convert it to a buffered body. The buffered body will share the same chunks as the rewindable body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#58
  def buffered; end

  # Returns the value of attribute chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#53
  def chunks; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#73
  def clear; end

  # Ensure that future reads return nil, but allow for rewinding.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#67
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#111
  def close_write(error); end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#102
  def discard; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#83
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#62
  def finish; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#127
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#79
  def length; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#92
  def read; end

  # A buffered response is always ready.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#88
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#119
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#115
  def rewindable?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#107
  def write(chunk); end

  class << self
    # Read the entire body into a buffered representation.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#36
    def read(body); end

    # Tries to wrap an object in a {Buffered} instance.
    #
    # For compatibility, also accepts anything that behaves like an `Array(String)`.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#20
    def wrap(object); end
  end
end

# Invokes a callback once the body has completed, either successfully or due to an error.
#
# source://protocol-http//lib/protocol/http/body/completable.rb#12
class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  # @return [Completable] a new instance of Completable
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#21
  def initialize(body, callback); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#35
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#31
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#27
  def rewindable?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/completable.rb#13
    def wrap(message, &block); end
  end
end

# source://protocol-http//lib/protocol/http/body/deflate.rb#63
class Protocol::HTTP::Body::Deflate < ::Protocol::HTTP::Body::ZStream
  # source://protocol-http//lib/protocol/http/body/deflate.rb#68
  def read; end

  class << self
    # source://protocol-http//lib/protocol/http/body/deflate.rb#64
    def for(body, window_size = T.unsafe(nil), level = T.unsafe(nil)); end
  end
end

# Invokes a callback once the body has finished reading.
#
# source://protocol-http//lib/protocol/http/body/digestable.rb#14
class Protocol::HTTP::Body::Digestable < ::Protocol::HTTP::Body::Wrapper
  # @return [Digestable] a new instance of Digestable
  #
  # source://protocol-http//lib/protocol/http/body/digestable.rb#22
  def initialize(body, digest = T.unsafe(nil), callback = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/digestable.rb#29
  def digest; end

  # source://protocol-http//lib/protocol/http/body/digestable.rb#33
  def etag(weak: T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/digestable.rb#41
  def read; end

  class << self
    # source://protocol-http//lib/protocol/http/body/digestable.rb#15
    def wrap(message, digest = T.unsafe(nil), &block); end
  end
end

# source://protocol-http//lib/protocol/http/body/file.rb#11
class Protocol::HTTP::Body::File < ::Protocol::HTTP::Body::Readable
  # @return [File] a new instance of File
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#19
  def initialize(file, range = T.unsafe(nil), size: T.unsafe(nil), block_size: T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/file.rb#56
  def buffered; end

  # source://protocol-http//lib/protocol/http/body/file.rb#36
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#48
  def empty?; end

  # Returns the value of attribute file.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#43
  def file; end

  # source://protocol-http//lib/protocol/http/body/file.rb#101
  def inspect; end

  # def call(stream)
  # 	IO.copy_stream(@file, stream, @remaining)
  # ensure
  # 	stream.close
  # end
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#91
  def join; end

  # Returns the value of attribute length.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#46
  def length; end

  # Returns the value of attribute offset.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#45
  def offset; end

  # source://protocol-http//lib/protocol/http/body/file.rb#69
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#52
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/file.rb#60
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#65
  def rewindable?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/file.rb#15
    def open(path, *arguments, **options); end
  end
end

# source://protocol-http//lib/protocol/http/body/file.rb#12
Protocol::HTTP::Body::File::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/body/file.rb#13
Protocol::HTTP::Body::File::MODE = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/body/head.rb#11
class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  # @return [Head] a new instance of Head
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#20
  def initialize(length); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#24
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/head.rb#32
  def length; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#28
  def ready?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/head.rb#12
    def for(body); end
  end
end

# Represents a readable input streams.
#
# Typically, you'd override `#read` to return chunks of data.
#
# In general, you read chunks of data from a body until it is empty and returns `nil`. Upon reading `nil`, the body is considered consumed and should not be read from again.
#
# Reading can also fail, for example if the body represents a streaming upload, and the connection is lost. In this case, `#read` will raise some kind of error.
#
# If you don't want to read from a stream, and instead want to close it immediately, you can call `close` on the body. If the body is already completely consumed, `close` will do nothing, but if there is still data to be read, it will cause the underlying stream to be reset (and possibly closed).
#
# source://protocol-http//lib/protocol/http/body/readable.rb#19
class Protocol::HTTP::Body::Readable
  # source://protocol-http//lib/protocol/http/body/readable.rb#155
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Return a buffered representation of this body.
  #
  # This method must return a buffered body if `#rewindable?`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#58
  def buffered; end

  # Invoke the body with the given stream.
  #
  # The default implementation simply writes each chunk to the stream. If the body is not ready, it will be flushed after each chunk. Closes the stream when finished or if an error occurs.
  #
  # Write the body to the given stream.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#124
  def call(stream); end

  # Close the stream immediately. After invoking this method, the stream should be considered closed, and all internal resources should be released.
  #
  # If an error occured while handling the output, it can be passed as an argument. This may be propagated to the client, for example the client may be informed that the stream was not fully read correctly.
  #
  # Invoking `#read` after `#close` will return `nil`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#25
  def close(error = T.unsafe(nil)); end

  # Discard the body as efficiently as possible.
  #
  # The default implementation simply reads all chunks until the body is empty.
  #
  # Useful for discarding the body when it is not needed, but preserving the underlying connection.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#150
  def discard; end

  # Enumerate all chunks until finished, then invoke `#close`.
  #
  # Closes the stream when finished or if an error occurs.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#81
  def each; end

  # Optimistically determine whether read (may) return any data.
  # If this returns true, then calling read will definitely return nil.
  # If this returns false, then calling read may return nil.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#31
  def empty?; end

  # Read all remaining chunks into a buffered body and close the underlying input.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#140
  def finish; end

  # Read all remaining chunks into a single binary string using `#each`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#98
  def join; end

  # The total length of the body, if known.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#64
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#71
  def read; end

  # Whether calling read will return a chunk of data without blocking.
  # We prefer pessimistic implementation, and thus default to `false`.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#38
  def ready?; end

  # Rewind the stream to the beginning.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#49
  def rewind; end

  # Whether the stream can be rewound using {rewind}.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#43
  def rewindable?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#112
  def stream?; end

  # source://protocol-http//lib/protocol/http/body/readable.rb#165
  def to_json(*_arg0, **_arg1, &_arg2); end
end

# General operations for interacting with a request or response body.
#
# source://protocol-http//lib/protocol/http/body/reader.rb#11
module Protocol::HTTP::Body::Reader
  # Whether there is a body?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#81
  def body?; end

  # Buffer the entire request/response body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#53
  def buffered!; end

  # Close the connection as quickly as possible. Discards body. May close the underlying connection if necessary to terminate the stream.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#73
  def close(error = T.unsafe(nil)); end

  # Discard the body as efficiently as possible.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#44
  def discard; end

  # Read chunks from the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#14
  def each(&block); end

  # Gracefully finish reading the body. This will buffer the remainder of the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#34
  def finish; end

  # Reads the entire request/response body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#23
  def read; end

  # Write the body of the response to the given file path.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#62
  def save(path, mode = T.unsafe(nil), **options); end
end

# A body which buffers all it's contents as it is `#read`.
#
# source://protocol-http//lib/protocol/http/body/rewindable.rb#13
class Protocol::HTTP::Body::Rewindable < ::Protocol::HTTP::Body::Wrapper
  # @return [Rewindable] a new instance of Rewindable
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#24
  def initialize(body); end

  # A rewindable body wraps some other body. Convert it to a buffered body. The buffered body will share the same chunks as the rewindable body.
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#42
  def buffered; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#31
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/rewindable.rb#69
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/rewindable.rb#46
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#35
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/rewindable.rb#61
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/rewindable.rb#65
  def rewindable?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/rewindable.rb#14
    def wrap(message); end
  end
end

# The input stream is an IO-like object which contains the raw HTTP POST data. When applicable, its external encoding must be “ASCII-8BIT” and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to gets, each, read and rewind.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#13
class Protocol::HTTP::Body::Stream
  include ::Protocol::HTTP::Body::Stream::Reader

  # @raise [ArgumentError]
  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#16
  def initialize(input = T.unsafe(nil), output = T.unsafe(nil)); end

  # Write data to the stream using {write}.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#283
  def <<(buffer); end

  # Close the input and output bodies.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#330
  def close(error = T.unsafe(nil)); end

  # Close the input body.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#310
  def close_read(error = T.unsafe(nil)); end

  # Close the output body.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#321
  def close_write(error = T.unsafe(nil)); end

  # Whether the stream has been closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#340
  def closed?; end

  # Whether there are any output chunks remaining?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#345
  def empty?; end

  # Flush the output stream.
  #
  # This is currently a no-op.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#306
  def flush; end

  # Returns the value of attribute input.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#29
  def input; end

  # Returns the value of attribute output.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#30
  def output; end

  # Write lines to the stream.
  #
  # The current implementation buffers the lines and writes them in a single operation.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#293
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Write data to the underlying stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#262
  def write(buffer); end

  # Write data to the stream using {write}.
  #
  # Provided for compatibility with IO-like objects.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#278
  def write_nonblock(buffer, exception: T.unsafe(nil)); end

  private

  # source://protocol-http//lib/protocol/http/body/stream.rb#351
  def read_next; end
end

# source://protocol-http//lib/protocol/http/body/stream.rb#14
Protocol::HTTP::Body::Stream::NEWLINE = T.let(T.unsafe(nil), String)

# This provides a read-only interface for data, which is surprisingly tricky to implement correctly.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#33
module Protocol::HTTP::Body::Stream::Reader
  # Read a single line from the stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#196
  def gets(separator = T.unsafe(nil), limit = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Read data from the underlying stream.
  #
  # If given a non-negative length, it will read at most that many bytes from the stream. If the stream is at EOF, it will return nil.
  #
  # If the length is not given, it will read all data until EOF, or return an empty string if the stream is already at EOF.
  #
  # If buffer is given, then the read data will be placed into buffer instead of a newly created String object.
  #
  # @param length [Integer] the amount of data to read
  # @param buffer [String] the buffer which will receive the data
  # @return a buffer containing the data
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#45
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Read data from the stream without blocking if possible.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#133
  def read_nonblock(length, buffer = T.unsafe(nil), exception: T.unsafe(nil)); end

  # Read some bytes from the stream.
  #
  # If the length is given, at most length bytes will be read. Otherwise, one chunk of data from the underlying stream will be read.
  #
  # Will avoid reading from the underlying stream if there is buffered data available.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#93
  def read_partial(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Read data from the stream until encountering pattern.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#165
  def read_until(pattern, offset = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Similar to {read_partial} but raises an `EOFError` if the stream is at EOF.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#128
  def readpartial(length, buffer = T.unsafe(nil)); end
end

# A body that invokes a block that can read and write to a stream.
#
# In some cases, it's advantageous to directly read and write to the underlying stream if possible. For example, HTTP/1 upgrade requests, WebSockets, and similar. To handle that case, response bodies can implement `stream?` and return `true`. When `stream?` returns true, the body **should** be consumed by calling `call(stream)`. Server implementations may choose to always invoke `call(stream)` if it's efficient to do so. Bodies that don't support it will fall back to using `#each`.
#
# When invoking `call(stream)`, the stream can be read from and written to, and closed. However, the stream is only guaranteed to be open for the duration of the `call(stream)` call. Once the method returns, the stream **should** be closed by the server.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#19
module Protocol::HTTP::Body::Streamable
  class << self
    # source://protocol-http//lib/protocol/http/body/streamable.rb#20
    def request(&block); end

    # source://protocol-http//lib/protocol/http/body/streamable.rb#24
    def response(request, &block); end
  end
end

# source://protocol-http//lib/protocol/http/body/streamable.rb#58
class Protocol::HTTP::Body::Streamable::Body < ::Protocol::HTTP::Body::Readable
  # @return [Body] a new instance of Body
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#59
  def initialize(block, input = T.unsafe(nil)); end

  # Invoke the block with the given stream.
  #
  # The block can read and write to the stream, and must close the stream when finishing.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#87
  def call(stream); end

  # source://protocol-http//lib/protocol/http/body/streamable.rb#104
  def close_input(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/streamable.rb#111
  def close_output(error = T.unsafe(nil)); end

  # Invokes the block in a fiber which yields chunks when they are available.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#70
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#65
  def stream?; end
end

# Raised when a streaming body is consumed more than once.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#55
class Protocol::HTTP::Body::Streamable::ConsumedError < ::StandardError; end

# source://protocol-http//lib/protocol/http/body/streamable.rb#28
class Protocol::HTTP::Body::Streamable::Output
  # @return [Output] a new instance of Output
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#33
  def initialize(input, block); end

  # source://protocol-http//lib/protocol/http/body/streamable.rb#49
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/streamable.rb#45
  def read; end

  # source://protocol-http//lib/protocol/http/body/streamable.rb#39
  def schedule; end

  class << self
    # source://protocol-http//lib/protocol/http/body/streamable.rb#29
    def schedule(input, block); end
  end
end

# A request body is used on the client side to generate the request body using a block.
#
# As the response body isn't available until the request is sent, the response body must be {stream}ed into the request body.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#127
class Protocol::HTTP::Body::Streamable::RequestBody < ::Protocol::HTTP::Body::Streamable::Body
  # @return [RequestBody] a new instance of RequestBody
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#128
  def initialize(block); end

  # source://protocol-http//lib/protocol/http/body/streamable.rb#132
  def close(error = T.unsafe(nil)); end

  # Stream the response body into the block's input.
  #
  # source://protocol-http//lib/protocol/http/body/streamable.rb#138
  def stream(body); end
end

# A response body is used on the server side to generate the response body using a block.
#
# source://protocol-http//lib/protocol/http/body/streamable.rb#117
class Protocol::HTTP::Body::Streamable::ResponseBody < ::Protocol::HTTP::Body::Streamable::Body
  # source://protocol-http//lib/protocol/http/body/streamable.rb#118
  def close(error = T.unsafe(nil)); end
end

# Wrapping body instance. Typically you'd override `#read`.
#
# source://protocol-http//lib/protocol/http/body/wrapper.rb#12
class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#23
  def initialize(body); end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#70
  def as_json(*_arg0, **_arg1, &_arg2); end

  # The wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#28
  def body; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#45
  def buffered; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#30
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#66
  def discard; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#37
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#81
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#57
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#62
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#41
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#49
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#53
  def rewindable?; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#77
  def to_json(*_arg0, **_arg1, &_arg2); end

  class << self
    # Wrap the body of the given message in a new instance of this class.
    #
    # source://protocol-http//lib/protocol/http/body/wrapper.rb#17
    def wrap(message); end
  end
end

# A dynamic body which you can write to and read from.
#
# source://protocol-http//lib/protocol/http/body/writable.rb#12
class Protocol::HTTP::Body::Writable < ::Protocol::HTTP::Body::Readable
  # @param length [Integer] The length of the response body if known.
  # @param queue [Async::Queue] Specify a different queue implementation, e.g. `Async::LimitedQueue.new(8)` to enable back-pressure streaming.
  # @return [Writable] a new instance of Writable
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#18
  def initialize(length = T.unsafe(nil), queue: T.unsafe(nil)); end

  # Stop generating output; cause the next call to write to fail with the given error. Does not prevent existing chunks from being read. In other words, this indicates both that no more data will be or should be written to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#30
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/writable.rb#78
  def close_write(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#39
  def closed?; end

  # Has the producer called #finish and has the reader consumed the nil token?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#48
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/writable.rb#127
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/writable.rb#25
  def length; end

  # Create an output wrapper which can be used to write chunks to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#111
  def output; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#53
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#43
  def ready?; end

  # Write a single chunk to the body. Signal completion by calling `#finish`.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#69
  def write(chunk); end

  private

  # source://protocol-http//lib/protocol/http/body/writable.rb#137
  def status; end
end

# source://protocol-http//lib/protocol/http/body/writable.rb#13
class Protocol::HTTP::Body::Writable::Closed < ::StandardError; end

# source://protocol-http//lib/protocol/http/body/writable.rb#83
class Protocol::HTTP::Body::Writable::Output
  # @return [Output] a new instance of Output
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#84
  def initialize(writable); end

  # source://protocol-http//lib/protocol/http/body/writable.rb#93
  def <<(chunk); end

  # source://protocol-http//lib/protocol/http/body/writable.rb#99
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#89
  def closed?; end

  # source://protocol-http//lib/protocol/http/body/writable.rb#93
  def write(chunk); end
end

# source://protocol-http//lib/protocol/http/body/deflate.rb#13
class Protocol::HTTP::Body::ZStream < ::Protocol::HTTP::Body::Wrapper
  # @return [ZStream] a new instance of ZStream
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#24
  def initialize(body, stream); end

  # source://protocol-http//lib/protocol/http/body/deflate.rb#33
  def close(error = T.unsafe(nil)); end

  # Returns the value of attribute input_length.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#47
  def input_length; end

  # source://protocol-http//lib/protocol/http/body/deflate.rb#58
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/deflate.rb#42
  def length; end

  # Returns the value of attribute output_length.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#48
  def output_length; end

  # source://protocol-http//lib/protocol/http/body/deflate.rb#50
  def ratio; end
end

# source://protocol-http//lib/protocol/http/body/deflate.rb#14
Protocol::HTTP::Body::ZStream::DEFAULT_LEVEL = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/body/deflate.rb#16
Protocol::HTTP::Body::ZStream::DEFLATE = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/body/deflate.rb#19
Protocol::HTTP::Body::ZStream::ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/body/deflate.rb#17
Protocol::HTTP::Body::ZStream::GZIP = T.let(T.unsafe(nil), Integer)

# Encode a response according the the request's acceptable encodings.
#
# source://protocol-http//lib/protocol/http/content_encoding.rb#14
class Protocol::HTTP::ContentEncoding < ::Protocol::HTTP::Middleware
  # @return [ContentEncoding] a new instance of ContentEncoding
  #
  # source://protocol-http//lib/protocol/http/content_encoding.rb#21
  def initialize(app, content_types = T.unsafe(nil), wrappers = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/content_encoding.rb#28
  def call(request); end
end

# source://protocol-http//lib/protocol/http/content_encoding.rb#19
Protocol::HTTP::ContentEncoding::DEFAULT_CONTENT_TYPES = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/content_encoding.rb#15
Protocol::HTTP::ContentEncoding::DEFAULT_WRAPPERS = T.let(T.unsafe(nil), Hash)

# Represents an individual cookie key-value pair.
#
# source://protocol-http//lib/protocol/http/cookie.rb#12
class Protocol::HTTP::Cookie
  # @return [Cookie] a new instance of Cookie
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#13
  def initialize(name, value, directives); end

  # Returns the value of attribute directives.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#21
  def directives; end

  # source://protocol-http//lib/protocol/http/cookie.rb#23
  def encoded_name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#27
  def encoded_value; end

  # Returns the value of attribute name.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#19
  def name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#31
  def to_s; end

  # Returns the value of attribute value.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#20
  def value; end

  class << self
    # source://protocol-http//lib/protocol/http/cookie.rb#52
    def parse(string); end

    # source://protocol-http//lib/protocol/http/cookie.rb#65
    def parse_directives(strings); end
  end
end

# A generic, HTTP protocol error.
#
# source://protocol-http//lib/protocol/http/error.rb#9
class Protocol::HTTP::Error < ::StandardError; end

# source://protocol-http//lib/protocol/http/header/split.rb#8
module Protocol::HTTP::Header; end

# Used for basic authorization.
#
# ~~~ ruby
# headers.add('authorization', Authorization.basic("my_username", "my_password"))
# ~~~
#
# source://protocol-http//lib/protocol/http/header/authorization.rb#15
class Protocol::HTTP::Header::Authorization < ::String
  # Splits the header and
  #
  # @return [Tuple(String, String)]
  #
  # source://protocol-http//lib/protocol/http/header/authorization.rb#18
  def credentials; end

  class << self
    # source://protocol-http//lib/protocol/http/header/authorization.rb#22
    def basic(username, password); end
  end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#12
class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  # @return [CacheControl] a new instance of CacheControl
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#27
  def initialize(value = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#31
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#39
  def dynamic?; end

  # The maximum time, in seconds, a response should be considered fresh.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-max-age-2
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#77
  def max_age; end

  # Indicates that a response must not be used once it is stale.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-must-revalidate
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#65
  def must_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#55
  def no_cache?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#59
  def no_store?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#47
  def private?; end

  # Like must-revalidate, but for shared caches only.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-proxy-revalidate
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#71
  def proxy_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#51
  def public?; end

  # Like max-age, but for shared caches only, which should use it before
  # max-age when present.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-s-maxage
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#84
  def s_maxage; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#35
  def static?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#43
  def streaming?; end

  private

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#90
  def find_integer_value(value_name); end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#21
Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#17
Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#24
Protocol::HTTP::Header::CacheControl::MUST_REVALIDATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#15
Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#16
Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#13
Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#25
Protocol::HTTP::Header::CacheControl::PROXY_REVALIDATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#14
Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#20
Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#22
Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#18
Protocol::HTTP::Header::CacheControl::S_MAXAGE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#12
class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#17
  def initialize(value = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/header/connection.rb#21
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#29
  def close?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#25
  def keep_alive?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#33
  def upgrade?; end
end

# source://protocol-http//lib/protocol/http/header/connection.rb#14
Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#13
Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#15
Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

# The Cookie HTTP request header contains stored HTTP cookies previously sent by the server with the Set-Cookie header.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#13
class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  # source://protocol-http//lib/protocol/http/header/cookie.rb#14
  def to_h; end
end

# source://protocol-http//lib/protocol/http/header/date.rb#11
class Protocol::HTTP::Header::Date < ::String
  # source://protocol-http//lib/protocol/http/header/date.rb#12
  def <<(value); end

  # source://protocol-http//lib/protocol/http/header/date.rb#16
  def to_time; end
end

# source://protocol-http//lib/protocol/http/header/etag.rb#9
class Protocol::HTTP::Header::ETag < ::String
  # source://protocol-http//lib/protocol/http/header/etag.rb#10
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#14
  def weak?; end
end

# source://protocol-http//lib/protocol/http/header/etags.rb#12
class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  # This implementation is not strictly correct according to the RFC-specified format.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#18
  def match?(etag); end

  # Useful with If-Match
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#23
  def strong_match?(etag); end

  # Useful with If-None-Match
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#28
  def weak_match?(etag); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#13
  def wildcard?; end

  private

  # source://protocol-http//lib/protocol/http/header/etags.rb#34
  def opposite_tag(etag); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#38
  def weak_tag?(tag); end
end

# Header value which is split by newline charaters (e.g. cookies).
#
# source://protocol-http//lib/protocol/http/header/multiple.rb#10
class Protocol::HTTP::Header::Multiple < ::Array
  # @return [Multiple] a new instance of Multiple
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#11
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/multiple.rb#17
  def to_s; end
end

# The Set-Cookie HTTP response header sends cookies from the server to the user agent.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#24
class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie; end

# Header value which is split by commas.
#
# source://protocol-http//lib/protocol/http/header/split.rb#10
class Protocol::HTTP::Header::Split < ::Array
  # @return [Split] a new instance of Split
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#13
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#21
  def <<(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#25
  def to_s; end
end

# source://protocol-http//lib/protocol/http/header/split.rb#11
Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/vary.rb#11
class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  # @return [Vary] a new instance of Vary
  #
  # source://protocol-http//lib/protocol/http/header/vary.rb#12
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/vary.rb#16
  def <<(value); end
end

# Headers are an array of key-value pairs. Some header keys represent multiple values.
#
# source://protocol-http//lib/protocol/http/headers.rb#20
class Protocol::HTTP::Headers
  # @return [Headers] a new instance of Headers
  #
  # source://protocol-http//lib/protocol/http/headers.rb#50
  def initialize(fields = T.unsafe(nil), indexed = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/headers.rb#308
  def ==(other); end

  # source://protocol-http//lib/protocol/http/headers.rb#289
  def [](key); end

  # Append the value to the given key. Some values can be appended multiple times, others can only be set once.
  #
  # @param key [String] The header key.
  # @param value The header value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#196
  def []=(key, value); end

  # Add the specified header key value pair.
  #
  # @param key [String] the header key.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#168
  def add(key, value); end

  # A hash table of `{key, policy[key].map(values)}`
  #
  # source://protocol-http//lib/protocol/http/headers.rb#294
  def as_json; end

  # source://protocol-http//lib/protocol/http/headers.rb#65
  def clear; end

  # Delete all headers with the given key, and return the merged value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#252
  def delete(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#136
  def each(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#132
  def empty?; end

  # source://protocol-http//lib/protocol/http/headers.rb#150
  def extract(keys); end

  # An array of `[key, value]` pairs.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#86
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#81
  def flatten; end

  # Flatten trailer into the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#72
  def flatten!; end

  # source://protocol-http//lib/protocol/http/headers.rb#120
  def freeze; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#140
  def include?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#304
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#140
  def key?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#146
  def keys; end

  # source://protocol-http//lib/protocol/http/headers.rb#189
  def merge(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#181
  def merge!(headers); end

  # Set the specified header key to the specified value, replacing any existing header keys with the same name.
  #
  # @param key [String] the header key to replace.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#175
  def set(key, value); end

  # A hash table of `{key, policy[key].map(values)}`
  #
  # source://protocol-http//lib/protocol/http/headers.rb#294
  def to_h; end

  # Enumerate all headers in the trailer, if there are any.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#112
  def trailer(&block); end

  # Record the current headers, and prepare to add trailers.
  #
  # This method is typically used after headers are sent to capture any
  # additional headers which should then be sent as trailers.
  #
  # A sender that intends to generate one or more trailer fields in a
  # message should generate a trailer header field in the header section of
  # that message to indicate which fields might be present in the trailers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#105
  def trailer!(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#89
  def trailer?; end

  protected

  # source://protocol-http//lib/protocol/http/headers.rb#276
  def merge_into(hash, key, value); end

  private

  # source://protocol-http//lib/protocol/http/headers.rb#58
  def initialize_dup(other); end

  class << self
    # Construct an instance from a headers Array or Hash. No-op if already an instance of `Headers`. If the underlying array is frozen, it will be duped.
    #
    # @return [Headers] an instance of headers.
    #
    # source://protocol-http//lib/protocol/http/headers.rb#28
    def [](headers); end
  end
end

# Used for merging objects into a sequential list of headers. Normalizes header keys and values.
#
# source://protocol-http//lib/protocol/http/headers.rb#320
class Protocol::HTTP::Headers::Merged
  include ::Enumerable

  # @return [Merged] a new instance of Merged
  #
  # source://protocol-http//lib/protocol/http/headers.rb#323
  def initialize(*all); end

  # source://protocol-http//lib/protocol/http/headers.rb#339
  def <<(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#335
  def clear; end

  # source://protocol-http//lib/protocol/http/headers.rb#346
  def each(&block); end

  # source://protocol-http//lib/protocol/http/headers.rb#327
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#331
  def flatten; end
end

# source://protocol-http//lib/protocol/http/headers.rb#22
Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple

# source://protocol-http//lib/protocol/http/headers.rb#204
Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/headers.rb#21
Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split

# source://protocol-http//lib/protocol/http/headers.rb#24
Protocol::HTTP::Headers::TRAILER = T.let(T.unsafe(nil), String)

# Provides a convenient interface for commonly supported HTTP methods.
#
# | Method Name | Request Body | Response Body | Safe | Idempotent | Cacheable |
# | ----------- | ------------ | ------------- | ---- | ---------- | --------- |
# | GET         | Optional     | Yes           | Yes  | Yes        | Yes       |
# | HEAD        | Optional     | No            | Yes  | Yes        | Yes       |
# | POST        | Yes          | Yes           | No   | No         | Yes       |
# | PUT         | Yes          | Yes           | No   | Yes        | No        |
# | DELETE      | Optional     | Yes           | No   | Yes        | No        |
# | CONNECT     | Optional     | Yes           | No   | No         | No        |
# | OPTIONS     | Optional     | Yes           | Yes  | Yes        | No        |
# | TRACE       | No           | Yes           | Yes  | Yes        | No        |
# | PATCH       | Yes          | Yes           | No   | No         | No        |
#
# These methods are defined in this module using lower case names. They are for convenience only and you should not overload those methods.
#
# See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods> for more details.
#
# source://protocol-http//lib/protocol/http/methods.rb#25
class Protocol::HTTP::Methods
  # source://protocol-http//lib/protocol/http/methods.rb#73
  def connect(location, *arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def delete(location, *arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def get(location, *arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def head(location, *arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def options(location, *arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def patch(location, *arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def post(location, *arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def put(location, *arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def trace(location, *arguments, **options); end

  class << self
    # Enumerate all HTTP methods.
    #
    # source://protocol-http//lib/protocol/http/methods.rb#64
    def each; end

    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/methods.rb#53
    def valid?(name); end
  end
end

# The CONNECT method establishes a tunnel to the server identified by the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#42
Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)

# The DELETE method deletes the specified resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#39
Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)

# The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
#
# source://protocol-http//lib/protocol/http/methods.rb#27
Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)

# The HEAD method asks for a response identical to a GET request, but without the response body.
#
# source://protocol-http//lib/protocol/http/methods.rb#30
Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)

# The OPTIONS method describes the communication options for the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#45
Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)

# The PATCH method applies partial modifications to a resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#51
Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)

# The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.
#
# source://protocol-http//lib/protocol/http/methods.rb#33
Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)

# The PUT method replaces all current representations of the target resource with the request payload.
#
# source://protocol-http//lib/protocol/http/methods.rb#36
Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)

# The TRACE method performs a message loop-back test along the path to the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#48
Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)

# The middleware interface provides a convenient wrapper for implementing HTTP middleware.
#
# A middleware instance generally needs to respond to two methods:
#
# - `call(request)` -> `response`
# - `close()`
#
# The call method is called for each request. The close method is called when the server is shutting down.
#
# You do not need to use the Middleware class to implement middleware. You can implement the interface directly.
#
# source://protocol-http//lib/protocol/http/middleware.rb#23
class Protocol::HTTP::Middleware < ::Protocol::HTTP::Methods
  # @return [Middleware] a new instance of Middleware
  #
  # source://protocol-http//lib/protocol/http/middleware.rb#32
  def initialize(delegate); end

  # source://protocol-http//lib/protocol/http/middleware.rb#42
  def call(request); end

  # source://protocol-http//lib/protocol/http/middleware.rb#38
  def close; end

  # Returns the value of attribute delegate.
  #
  # source://protocol-http//lib/protocol/http/middleware.rb#36
  def delegate; end

  class << self
    # source://protocol-http//lib/protocol/http/middleware/builder.rb#30
    def build(&block); end

    # Convert a block to a middleware delegate.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#25
    def for(&block); end
  end
end

# source://protocol-http//lib/protocol/http/middleware/builder.rb#11
class Protocol::HTTP::Middleware::Builder
  # @return [Builder] a new instance of Builder
  #
  # source://protocol-http//lib/protocol/http/middleware/builder.rb#12
  def initialize(default_app = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/middleware/builder.rb#21
  def run(app); end

  # source://protocol-http//lib/protocol/http/middleware/builder.rb#25
  def to_app; end

  # source://protocol-http//lib/protocol/http/middleware/builder.rb#17
  def use(middleware, *arguments, **options, &block); end
end

# source://protocol-http//lib/protocol/http/middleware.rb#64
module Protocol::HTTP::Middleware::HelloWorld
  class << self
    # source://protocol-http//lib/protocol/http/middleware.rb#68
    def call(request); end

    # source://protocol-http//lib/protocol/http/middleware.rb#65
    def close; end
  end
end

# source://protocol-http//lib/protocol/http/middleware.rb#55
module Protocol::HTTP::Middleware::NotFound
  class << self
    # source://protocol-http//lib/protocol/http/middleware.rb#59
    def call(request); end

    # source://protocol-http//lib/protocol/http/middleware.rb#56
    def close; end
  end
end

# source://protocol-http//lib/protocol/http/middleware.rb#46
module Protocol::HTTP::Middleware::Okay
  class << self
    # source://protocol-http//lib/protocol/http/middleware.rb#50
    def call(request); end

    # source://protocol-http//lib/protocol/http/middleware.rb#47
    def close; end
  end
end

# Represents an HTTP request which can be used both server and client-side.
#
# ~~~ ruby
# require 'protocol/http'
#
# # Long form:
# Protocol::HTTP::Request.new("http", "example.com", "GET", "/index.html", "HTTP/1.1", Protocol::HTTP::Headers[["accept", "text/html"]])
#
# # Short form:
# Protocol::HTTP::Request["GET", "/index.html", {"accept" => "text/html"}]
# ~~~
#
# source://protocol-http//lib/protocol/http/request.rb#25
class Protocol::HTTP::Request
  include ::Protocol::HTTP::Body::Reader

  # @return [Request] a new instance of Request
  #
  # source://protocol-http//lib/protocol/http/request.rb#28
  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil), interim_response = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/request.rb#116
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute authority.
  #
  # source://protocol-http//lib/protocol/http/request.rb#44
  def authority; end

  # Sets the attribute authority
  #
  # @param value the value to set the attribute authority to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#44
  def authority=(_arg0); end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/request.rb#59
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#59
  def body=(_arg0); end

  # Send the request to the given connection.
  #
  # source://protocol-http//lib/protocol/http/request.rb#68
  def call(connection); end

  # Whether this is a CONNECT request: typically used to establish a tunnel.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#94
  def connect?; end

  # Whether this is a HEAD request: no body is expected in the response.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#89
  def head?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/request.rb#56
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#56
  def headers=(_arg0); end

  # Whether the request can be replayed without side-effects.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#112
  def idempotent?; end

  # Returns the value of attribute interim_response.
  #
  # source://protocol-http//lib/protocol/http/request.rb#65
  def interim_response; end

  # Sets the attribute interim_response
  #
  # @param value the value to set the attribute interim_response to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#65
  def interim_response=(_arg0); end

  # Returns the value of attribute method.
  #
  # source://protocol-http//lib/protocol/http/request.rb#47
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#47
  def method=(_arg0); end

  # source://protocol-http//lib/protocol/http/request.rb#77
  def on_interim_response(&block); end

  # Returns the value of attribute path.
  #
  # source://protocol-http//lib/protocol/http/request.rb#50
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#50
  def path=(_arg0); end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/request.rb#62
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#62
  def protocol=(_arg0); end

  # Returns the value of attribute scheme.
  #
  # source://protocol-http//lib/protocol/http/request.rb#41
  def scheme; end

  # Sets the attribute scheme
  #
  # @param value the value to set the attribute scheme to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#41
  def scheme=(_arg0); end

  # Send an interim response back to the origin of this request, if possible.
  #
  # source://protocol-http//lib/protocol/http/request.rb#73
  def send_interim_response(status, headers); end

  # source://protocol-http//lib/protocol/http/request.rb#129
  def to_json(*_arg0, **_arg1, &_arg2); end

  # source://protocol-http//lib/protocol/http/request.rb#133
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/request.rb#53
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#53
  def version=(_arg0); end

  class << self
    # A short-cut method which exposes the main request variables that you'd typically care about.
    #
    # source://protocol-http//lib/protocol/http/request.rb#104
    def [](method, path, _headers = T.unsafe(nil), _body = T.unsafe(nil), scheme: T.unsafe(nil), authority: T.unsafe(nil), headers: T.unsafe(nil), body: T.unsafe(nil), protocol: T.unsafe(nil), interim_response: T.unsafe(nil)); end
  end
end

# Represents an HTTP response which can be used both server and client-side.
#
# ~~~ ruby
# require 'protocol/http'
#
# # Long form:
# Protocol::HTTP::Response.new("http/1.1", 200, Protocol::HTTP::Headers[["content-type", "text/html"]], Protocol::HTTP::Body::Buffered.wrap("Hello, World!"))
#
# # Short form:
# Protocol::HTTP::Response[200, {"content-type" => "text/html"}, ["Hello, World!"]]
# ~~~
#
# source://protocol-http//lib/protocol/http/response.rb#22
class Protocol::HTTP::Response
  include ::Protocol::HTTP::Body::Reader

  # Create a new response.
  #
  # @return [Response] a new instance of Response
  #
  # source://protocol-http//lib/protocol/http/response.rb#32
  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/response.rb#147
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Whether the status is 400 (bad request).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#112
  def bad_request?; end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/response.rb#50
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#50
  def body=(_arg0); end

  # Whether the status is 100 (continue).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#61
  def continue?; end

  # Whether the status is considered a failure.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#107
  def failure?; end

  # Whether the status is considered final. Note that 101 is considered final.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#71
  def final?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/response.rb#47
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#47
  def headers=(_arg0); end

  # Whether the response is considered a hijack: the connection has been taken over by the application and the server should not send any more data.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#56
  def hijack?; end

  # Whether the status is considered informational.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#66
  def informational?; end

  # Whether the status is 500 (internal server error).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#117
  def internal_server_error?; end

  # Whether the status is 304 (not modified).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#97
  def not_modified?; end

  # Whether the status is 200 (ok).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#77
  def ok?; end

  # Whether the status is 206 (partial content).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#87
  def partial?; end

  # Whether the status is 307 (temporary redirect) and should preserve the method of the request when following the redirect.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#102
  def preserve_method?; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/response.rb#53
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#53
  def protocol=(_arg0); end

  # Whether the status is considered a redirection.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#92
  def redirection?; end

  # Whether the status is 500 (internal server error).
  #
  # @deprecated Use {#internal_server_error?} instead.
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#117
  def server_failure?; end

  # Returns the value of attribute status.
  #
  # source://protocol-http//lib/protocol/http/response.rb#44
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#44
  def status=(_arg0); end

  # Whether the status is considered successful.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#82
  def success?; end

  # source://protocol-http//lib/protocol/http/response.rb#165
  def to_ary; end

  # source://protocol-http//lib/protocol/http/response.rb#157
  def to_json(*_arg0, **_arg1, &_arg2); end

  # source://protocol-http//lib/protocol/http/response.rb#161
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/response.rb#41
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#41
  def version=(_arg0); end

  class << self
    # A short-cut method which exposes the main response variables that you'd typically care about. It follows the same order as the `Rack` response tuple, but also includes the protocol.
    #
    # ~~~ ruby
    # 	Response[200, {"content-type" => "text/html"}, ["Hello, World!"]]
    # ~~~
    #
    # source://protocol-http//lib/protocol/http/response.rb#133
    def [](status, _headers = T.unsafe(nil), _body = T.unsafe(nil), headers: T.unsafe(nil), body: T.unsafe(nil), protocol: T.unsafe(nil)); end

    # Create a response for the given exception.
    #
    # source://protocol-http//lib/protocol/http/response.rb#143
    def for_exception(exception); end
  end
end

# source://protocol-http//lib/protocol/http/url.rb#9
module Protocol::HTTP::URL
  class << self
    # Assign a value to a nested hash.
    #
    # source://protocol-http//lib/protocol/http/url.rb#77
    def assign(keys, value, parent); end

    # TODO use native C extension from `Trenni::Reference`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#98
    def decode(string, maximum = T.unsafe(nil), symbolize_keys: T.unsafe(nil)); end

    # Encodes a hash or array into a query string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#36
    def encode(value, prefix = T.unsafe(nil)); end

    # Escapes a string using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#11
    def escape(string, encoding = T.unsafe(nil)); end

    # Escapes non-path characters using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#28
    def escape_path(path); end

    # Scan a string for URL-encoded key/value pairs.
    #
    # source://protocol-http//lib/protocol/http/url.rb#59
    def scan(string); end

    # source://protocol-http//lib/protocol/http/url.rb#69
    def split(name); end

    # Unescapes a percent encoded string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#18
    def unescape(string, encoding = T.unsafe(nil)); end
  end
end

# According to https://tools.ietf.org/html/rfc3986#section-3.3, we escape non-pchar.
#
# source://protocol-http//lib/protocol/http/url.rb#25
Protocol::HTTP::URL::NON_PCHAR = T.let(T.unsafe(nil), Regexp)
