# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http1` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http1`.


# source://protocol-http1//lib/protocol/http1/version.rb#6
module Protocol; end

# source://protocol-http1//lib/protocol/http1/version.rb#7
module Protocol::HTTP1; end

# A header name or value was invalid, e.g. contains invalid characters.
#
# source://protocol-http1//lib/protocol/http1/error.rb#25
class Protocol::HTTP1::BadHeader < ::Protocol::HTTP1::BadRequest; end

# The request was not able to be parsed correctly, or failed some kind of validation.
#
# source://protocol-http1//lib/protocol/http1/error.rb#21
class Protocol::HTTP1::BadRequest < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#11
module Protocol::HTTP1::Body; end

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#12
class Protocol::HTTP1::Body::Chunked < ::Protocol::HTTP::Body::Readable
  # @return [Chunked] a new instance of Chunked
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#15
  def initialize(connection, headers); end

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#38
  def close(error = T.unsafe(nil)); end

  # Returns the value of attribute count.
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#25
  def count; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#34
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#99
  def inspect; end

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#27
  def length; end

  # Follows the procedure outlined in https://tools.ietf.org/html/rfc7230#section-4.1.3
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#53
  def read; end

  private

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#105
  def read_trailer; end
end

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#13
Protocol::HTTP1::Body::Chunked::CRLF = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#50
Protocol::HTTP1::Body::Chunked::VALID_CHUNK_LENGTH = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/body/fixed.rb#11
class Protocol::HTTP1::Body::Fixed < ::Protocol::HTTP::Body::Readable
  # @return [Fixed] a new instance of Fixed
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#12
  def initialize(connection, length); end

  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#26
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#22
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#60
  def inspect; end

  # Returns the value of attribute length.
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#19
  def length; end

  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#39
  def read; end

  # Returns the value of attribute remaining.
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#20
  def remaining; end
end

# A body that reads all remaining data from the connection.
#
# source://protocol-http1//lib/protocol/http1/body/remainder.rb#12
class Protocol::HTTP1::Body::Remainder < ::Protocol::HTTP::Body::Readable
  # block_size may be removed in the future. It is better managed by connection.
  #
  # @return [Remainder] a new instance of Remainder
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#16
  def initialize(connection); end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#33
  def close(error = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#24
  def discard; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#20
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#50
  def inspect; end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#39
  def read; end
end

# source://protocol-http1//lib/protocol/http1/body/remainder.rb#13
Protocol::HTTP1::Body::Remainder::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http1//lib/protocol/http1/connection.rb#27
Protocol::HTTP1::CHUNKED = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#30
Protocol::HTTP1::CLOSE = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#29
Protocol::HTTP1::CONNECTION = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#24
Protocol::HTTP1::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#50
class Protocol::HTTP1::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#55
  def initialize(stream, persistent: T.unsafe(nil), state: T.unsafe(nil), maximum_line_length: T.unsafe(nil)); end

  # Close the connection and underlying stream.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#203
  def close(error = T.unsafe(nil)); end

  # Transition to the closed state.
  #
  # If no error occurred, and the connection is persistent, this will immediately transition to the idle state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#556
  def close!(error = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#196
  def close_read; end

  # The connection (stream) was closed. It may now be in the idle state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#548
  def closed(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#133
  def closed?; end

  # The number of requests processed.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#138
  def count; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#643
  def extract_content_length(headers); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#125
  def half_closed_local?; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#129
  def half_closed_remote?; end

  # Effectively close the connection and return the underlying IO.
  #
  # @return [IO] the underlying non-blocking IO.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#182
  def hijack!; end

  # Indicates whether the connection has been hijacked meaning its
  # IO has been handed over and is not usable anymore.
  #
  # @return [Boolean] hijack status
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#176
  def hijacked?; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#117
  def idle?; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#217
  def open!; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#121
  def open?; end

  # Whether the connection is persistent.
  # This determines what connection headers are sent in the response and whether
  # the connection can be reused after the response is sent.
  # This setting is automatically managed according to the nature of the request
  # and response.
  # Changing to false is safe.
  # Changing to true from outside this class should generally be avoided and,
  # depending on the response semantics, may be reset to false anyway.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#76
  def persistent; end

  # Whether the connection is persistent.
  # This determines what connection headers are sent in the response and whether
  # the connection can be reused after the response is sent.
  # This setting is automatically managed according to the nature of the request
  # and response.
  # Changing to false is safe.
  # Changing to true from outside this class should generally be avoided and,
  # depending on the response semantics, may be reset to false anyway.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#76
  def persistent=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#140
  def persistent?(version, method, headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#284
  def read(length); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#713
  def read_body(headers, remainder = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#608
  def read_chunked_body(headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#612
  def read_fixed_body(length); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#621
  def read_head_body(length); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#372
  def read_headers; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#299
  def read_line; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#288
  def read_line?; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#616
  def read_remainder_body; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#315
  def read_request; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#693
  def read_request_body(method, headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#303
  def read_request_line; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#348
  def read_response(method); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#653
  def read_response_body(method, status, headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#336
  def read_response_line; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#628
  def read_tunnel_body; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#632
  def read_upgrade_body; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#280
  def readpartial(length); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#598
  def receive_end_stream!; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#389
  def send_end_stream!; end

  # The current state of the connection.
  #
  # ```
  #                          ┌────────┐
  #                          │        │
  # ┌───────────────────────►│  idle  │
  # │                        │        │
  # │                        └───┬────┘
  # │                            │
  # │                            │ send request /
  # │                            │ receive request
  # │                            │
  # │                            ▼
  # │                        ┌────────┐
  # │                recv ES │        │ send ES
  # │           ┌────────────┤  open  ├────────────┐
  # │           │            │        │            │
  # │           ▼            └───┬────┘            ▼
  # │      ┌──────────┐          │           ┌──────────┐
  # │      │   half   │          │           │   half   │
  # │      │  closed  │          │ send R /  │  closed  │
  # │      │ (remote) │          │ recv R    │ (local)  │
  # │      └────┬─────┘          │           └─────┬────┘
  # │           │                │                 │
  # │           │ send ES /      │       recv ES / │
  # │           │ close          ▼           close │
  # │           │            ┌────────┐            │
  # │           └───────────►│        │◄───────────┘
  # │                        │ closed │
  # └────────────────────────┤        │
  #         persistent       └────────┘
  # ```
  #
  # - `ES`: the body was fully received or sent (end of stream).
  # - `R`: the connection was closed unexpectedly (reset).
  #
  # State transition methods use a trailing "!".
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#115
  def state; end

  # The current state of the connection.
  #
  # ```
  #                          ┌────────┐
  #                          │        │
  # ┌───────────────────────►│  idle  │
  # │                        │        │
  # │                        └───┬────┘
  # │                            │
  # │                            │ send request /
  # │                            │ receive request
  # │                            │
  # │                            ▼
  # │                        ┌────────┐
  # │                recv ES │        │ send ES
  # │           ┌────────────┤  open  ├────────────┐
  # │           │            │        │            │
  # │           ▼            └───┬────┘            ▼
  # │      ┌──────────┐          │           ┌──────────┐
  # │      │   half   │          │           │   half   │
  # │      │  closed  │          │ send R /  │  closed  │
  # │      │ (remote) │          │ recv R    │ (local)  │
  # │      └────┬─────┘          │           └─────┬────┘
  # │           │                │                 │
  # │           │ send ES /      │       recv ES / │
  # │           │ close          ▼           close │
  # │           │            ┌────────┐            │
  # │           └───────────►│        │◄───────────┘
  # │                        │ closed │
  # └────────────────────────┤        │
  #         persistent       └────────┘
  # ```
  #
  # - `ES`: the body was fully received or sent (end of stream).
  # - `R`: the connection was closed unexpectedly (reset).
  #
  # State transition methods use a trailing "!".
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#115
  def state=(_arg0); end

  # Returns the value of attribute stream.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#66
  def stream; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#567
  def write_body(version, body, head = T.unsafe(nil), trailer = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#524
  def write_body_and_close(body, head); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#488
  def write_chunked_body(body, head, trailer = T.unsafe(nil)); end

  # Write the appropriate header for connection persistence.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#161
  def write_connection_header(version); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#445
  def write_empty_body(body); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#454
  def write_fixed_length_body(body, length, head); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#260
  def write_headers(headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#247
  def write_interim_response(version, status, headers, reason = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#227
  def write_request(authority, method, path, version, headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#236
  def write_response(version, status, headers, reason = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#423
  def write_tunnel_body(version, body = T.unsafe(nil)); end

  # @param protocol [String] the protocol to upgrade to.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#400
  def write_upgrade_body(protocol, body = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#169
  def write_upgrade_header(upgrade); end

  private

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#344
  def interim_status?(status); end
end

# source://protocol-http1//lib/protocol/http1/connection.rb#639
Protocol::HTTP1::Connection::CONNECT = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#51
Protocol::HTTP1::Connection::CRLF = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#638
Protocol::HTTP1::Connection::HEAD = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#52
Protocol::HTTP1::Connection::HTTP10 = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#53
Protocol::HTTP1::Connection::HTTP11 = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#641
Protocol::HTTP1::Connection::VALID_CONTENT_LENGTH = T.let(T.unsafe(nil), Regexp)

# The specified content length and the given content's length do not match.
#
# source://protocol-http1//lib/protocol/http1/error.rb#33
class Protocol::HTTP1::ContentLengthError < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/connection.rb#48
Protocol::HTTP1::DEFAULT_MAXIMUM_LINE_LENGTH = T.let(T.unsafe(nil), Integer)

# source://protocol-http1//lib/protocol/http1/error.rb#10
class Protocol::HTTP1::Error < ::Protocol::HTTP::Error; end

# HTTP/1.x header parser:
#
# source://protocol-http1//lib/protocol/http1/connection.rb#41
Protocol::HTTP1::FIELD_NAME = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#42
Protocol::HTTP1::FIELD_VALUE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#43
Protocol::HTTP1::HEADER = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#33
Protocol::HTTP1::HOST = T.let(T.unsafe(nil), String)

# Indicates that the request is invalid for some reason, e.g. syntax error, invalid headers, etc.
#
# source://protocol-http1//lib/protocol/http1/error.rb#29
class Protocol::HTTP1::InvalidRequest < ::Protocol::HTTP1::BadRequest; end

# source://protocol-http1//lib/protocol/http1/connection.rb#31
Protocol::HTTP1::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/error.rb#17
class Protocol::HTTP1::LineLengthError < ::Protocol::HTTP1::Error; end

# The protocol was violated in some way, e.g. trying to write a request while reading a response.
#
# source://protocol-http1//lib/protocol/http1/error.rb#14
class Protocol::HTTP1::ProtocolError < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/connection.rb#38
Protocol::HTTP1::REQUEST_LINE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/reason.rb#10
module Protocol::HTTP1::Reason; end

# source://protocol-http1//lib/protocol/http1/reason.rb#11
Protocol::HTTP1::Reason::DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# HTTP/1.x request line parser:
#
# source://protocol-http1//lib/protocol/http1/connection.rb#37
Protocol::HTTP1::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#26
Protocol::HTTP1::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#34
Protocol::HTTP1::UPGRADE = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#45
Protocol::HTTP1::VALID_FIELD_NAME = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#46
Protocol::HTTP1::VALID_FIELD_VALUE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/version.rb#8
Protocol::HTTP1::VERSION = T.let(T.unsafe(nil), String)
