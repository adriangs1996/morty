# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-rack` gem.
# Please instead update this file by running `bin/tapioca gem protocol-rack`.


# source://protocol-rack//lib/protocol/rack/version.rb#6
module Protocol; end

# source://protocol-rack//lib/protocol/rack/version.rb#7
module Protocol::Rack; end

# source://protocol-rack//lib/protocol/rack/adapter/generic.rb#14
module Protocol::Rack::Adapter
  class << self
    # source://protocol-rack//lib/protocol/rack/adapter.rb#24
    def make_response(env, response); end

    # source://protocol-rack//lib/protocol/rack/adapter.rb#20
    def new(app); end

    # source://protocol-rack//lib/protocol/rack/adapter.rb#28
    def parse_file(*_arg0, **_arg1, &_arg2); end
  end
end

# source://protocol-rack//lib/protocol/rack/adapter/generic.rb#15
class Protocol::Rack::Adapter::Generic
  # Initialize the rack adaptor middleware.
  #
  # @raise [ArgumentError]
  # @return [Generic] a new instance of Generic
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#27
  def initialize(app); end

  # Build a rack `env` from the incoming request and apply it to the rack middleware.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#109
  def call(request); end

  # Generate a suitable response for the given exception.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#142
  def failure_response(exception); end

  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#33
  def logger; end

  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#100
  def make_environment(request); end

  # Unwrap raw HTTP headers into the CGI-style expected by Rack middleware.
  #
  # Rack separates multiple headers with the same key, into a single field with multiple lines.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#43
  def unwrap_headers(headers, env); end

  # Process the incoming request into a valid rack `env`.
  #
  # - Set the `env['CONTENT_TYPE']` and `env['CONTENT_LENGTH']` based on the incoming request body.
  # - Set the `env['HTTP_HOST']` header to the request authority.
  # - Set the `env['HTTP_X_FORWARDED_PROTO']` header to the request scheme.
  # - Set `env['REMOTE_ADDR']` to the request remote adress.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#68
  def unwrap_request(request, env); end

  class << self
    # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#146
    def extract_protocol(env, response, headers); end

    # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#20
    def parse_file(*_arg0, **_arg1, &_arg2); end

    # source://protocol-rack//lib/protocol/rack/adapter/generic.rb#16
    def wrap(app); end
  end
end

# source://protocol-rack//lib/protocol/rack/adapter.rb#15
Protocol::Rack::Adapter::IMPLEMENTATION = Protocol::Rack::Adapter::Rack3

# source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#14
class Protocol::Rack::Adapter::Rack2 < ::Protocol::Rack::Adapter::Generic
  # Build a rack `env` from the incoming request and apply it to the rack middleware.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#76
  def call(request); end

  # source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#24
  def make_environment(request); end

  # Process the rack response headers into into a {Protocol::HTTP::Headers} instance, along with any extra `rack.` metadata.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#99
  def wrap_headers(fields); end

  class << self
    # source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#120
    def make_response(env, response); end

    # source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#20
    def wrap(app); end
  end
end

# source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#17
Protocol::Rack::Adapter::Rack2::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#16
Protocol::Rack::Adapter::Rack2::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#18
Protocol::Rack::Adapter::Rack2::RACK_RUN_ONCE = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/adapter/rack2.rb#15
Protocol::Rack::Adapter::Rack2::RACK_VERSION = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#13
class Protocol::Rack::Adapter::Rack3 < ::Protocol::Rack::Adapter::Generic
  # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#22
  def make_environment(request); end

  # Process the rack response headers into into a {Protocol::HTTP::Headers} instance, along with any extra `rack.` metadata.
  #
  # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#71
  def wrap_headers(fields); end

  class << self
    # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#92
    def make_response(env, response); end

    # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#18
    def parse_file(*_arg0, **_arg1, &_arg2); end

    # source://protocol-rack//lib/protocol/rack/adapter/rack3.rb#14
    def wrap(app); end
  end
end

# source://protocol-rack//lib/protocol/rack/body/streaming.rb#10
module Protocol::Rack::Body
  class << self
    # source://protocol-rack//lib/protocol/rack/body.rb#47
    def completion_callback(response_finished, env, status, headers); end

    # source://protocol-rack//lib/protocol/rack/body.rb#15
    def wrap(env, status, headers, body, input = T.unsafe(nil)); end
  end
end

# source://protocol-rack//lib/protocol/rack/body.rb#13
Protocol::Rack::Body::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# Wraps the rack response body.
#
# The `rack` body must respond to `each` and must only yield `String` values. If the body responds to `close`, it will be called after iteration.
#
# source://protocol-rack//lib/protocol/rack/body/enumerable.rb#15
class Protocol::Rack::Body::Enumerable < ::Protocol::HTTP::Body::Readable
  # Initialize the output wrapper.
  #
  # @return [Enumerable] a new instance of Enumerable
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#32
  def initialize(body, length); end

  # The rack response body.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#40
  def body; end

  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#80
  def call(stream); end

  # Close the response body.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#56
  def close(error = T.unsafe(nil)); end

  # Enumerate the response body.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#70
  def each(&block); end

  # Whether the body is empty.
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#46
  def empty?; end

  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#96
  def inspect; end

  # The content length of the rack response body.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#43
  def length; end

  # Read the next chunk from the response body.
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#88
  def read; end

  # Whether the body can be read immediately.
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#51
  def ready?; end

  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#76
  def stream?; end

  class << self
    # Wraps an array into a buffered body.
    #
    # source://protocol-rack//lib/protocol/rack/body/enumerable.rb#20
    def wrap(body, length = T.unsafe(nil)); end
  end
end

# source://protocol-rack//lib/protocol/rack/body/enumerable.rb#16
Protocol::Rack::Body::Enumerable::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# Used for wrapping a generic `rack.input` object into a readable body.
#
# source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#13
class Protocol::Rack::Body::InputWrapper < ::Protocol::HTTP::Body::Readable
  # @return [InputWrapper] a new instance of InputWrapper
  #
  # source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#16
  def initialize(io, block_size: T.unsafe(nil)); end

  # source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#23
  def close(error = T.unsafe(nil)); end

  # def join
  # 	@io.read.tap do |buffer|
  # 		buffer.force_encoding(Encoding::BINARY)
  # 	end
  # end
  #
  # source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#36
  def read; end
end

# source://protocol-rack//lib/protocol/rack/body/input_wrapper.rb#14
Protocol::Rack::Body::InputWrapper::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-rack//lib/protocol/rack/body/streaming.rb#11
Protocol::Rack::Body::Streaming = Protocol::HTTP::Body::Streamable::ResponseBody

# CGI keys <https://tools.ietf.org/html/rfc3875#section-4.1>:
#
# source://protocol-rack//lib/protocol/rack/constants.rb#12
module Protocol::Rack::CGI; end

# source://protocol-rack//lib/protocol/rack/constants.rb#26
Protocol::Rack::CGI::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#25
Protocol::Rack::CGI::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#28
Protocol::Rack::CGI::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#13
Protocol::Rack::CGI::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#14
Protocol::Rack::CGI::HTTP_UPGRADE = T.let(T.unsafe(nil), String)

# Header constants:
#
# source://protocol-rack//lib/protocol/rack/constants.rb#31
Protocol::Rack::CGI::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#15
Protocol::Rack::CGI::PATH_INFO = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#20
Protocol::Rack::CGI::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#24
Protocol::Rack::CGI::REMOTE_ADDR = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#16
Protocol::Rack::CGI::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#17
Protocol::Rack::CGI::REQUEST_PATH = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#18
Protocol::Rack::CGI::REQUEST_URI = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#19
Protocol::Rack::CGI::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#22
Protocol::Rack::CGI::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#23
Protocol::Rack::CGI::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#21
Protocol::Rack::CGI::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# Wraps a streaming input body into the interface required by `rack.input`.
#
# The input stream is an `IO`-like object which contains the raw HTTP POST data. When applicable, its external encoding must be `ASCII-8BIT` and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to `gets`, `each`, `read` and `rewind`.
#
# This implementation is not always rewindable, to avoid buffering the input when handling large uploads. See {Rewindable} for more details.
#
# source://protocol-rack//lib/protocol/rack/input.rb#16
class Protocol::Rack::Input
  include ::Protocol::HTTP::Body::Stream::Reader

  # Initialize the input wrapper.
  #
  # @return [Input] a new instance of Input
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#19
  def initialize(body); end

  # The input body.
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#29
  def body; end

  # Close the input and output bodies.
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#47
  def close(error = T.unsafe(nil)); end

  # Whether the stream has been closed.
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#77
  def closed?; end

  # Enumerate chunks of the request body.
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#36
  def each(&block); end

  # Whether there are any input chunks remaining?
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#82
  def empty?; end

  # Rewind the input stream back to the start.
  #
  # `rewind` must be called without arguments. It rewinds the input stream back to the beginning. It must not raise Errno::ESPIPE: that is, it may not be a pipe or a socket. Therefore, handler developers must buffer the input data into some rewindable object if the underlying input stream is not rewindable.
  #
  # source://protocol-rack//lib/protocol/rack/input.rb#63
  def rewind; end

  private

  # source://protocol-rack//lib/protocol/rack/input.rb#88
  def read_next; end
end

# Used for injecting the raw request in the the rack environment.
#
# source://protocol-rack//lib/protocol/rack/constants.rb#9
Protocol::Rack::PROTOCOL_HTTP_REQUEST = T.let(T.unsafe(nil), String)

# Rack environment variables:
#
# source://protocol-rack//lib/protocol/rack/constants.rb#35
Protocol::Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#44
Protocol::Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#37
Protocol::Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# Rack hijack support:
#
# source://protocol-rack//lib/protocol/rack/constants.rb#43
Protocol::Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#36
Protocol::Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#39
Protocol::Rack::RACK_PROTOCOL = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#40
Protocol::Rack::RACK_RESPONSE_FINISHED = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/constants.rb#38
Protocol::Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/request.rb#14
class Protocol::Rack::Request < ::Protocol::HTTP::Request
  # @return [Request] a new instance of Request
  #
  # source://protocol-rack//lib/protocol/rack/request.rb#19
  def initialize(env); end

  class << self
    # source://protocol-rack//lib/protocol/rack/request.rb#15
    def [](env); end

    # source://protocol-rack//lib/protocol/rack/request.rb#42
    def headers(env); end

    # source://protocol-rack//lib/protocol/rack/request.rb#34
    def protocol(env); end
  end
end

# A wrapper for a `Rack` response.
#
# A Rack response consisting of `[status, headers, body]` includes various rack-specific elements, including:
#
# - A `headers['rack.hijack']` callback which bypasses normal response handling.
# - Potentially invalid content length.
# - Potentially invalid body when processing a `HEAD` request.
# - Newline-separated header values.
# - Other `rack.` specific header key/value pairs.
#
# This wrapper takes those issues into account and adapts the rack response tuple into a {Protocol::HTTP::Response}.
#
# source://protocol-rack//lib/protocol/rack/response.rb#26
class Protocol::Rack::Response < ::Protocol::HTTP::Response
  # Initialize the response wrapper.
  #
  # @return [Response] a new instance of Response
  #
  # source://protocol-rack//lib/protocol/rack/response.rb#76
  def initialize(status, headers, body, protocol = T.unsafe(nil)); end

  class << self
    # Wrap a rack response.
    #
    # source://protocol-rack//lib/protocol/rack/response.rb#42
    def wrap(env, status, headers, meta, body, request = T.unsafe(nil)); end
  end
end

# HTTP hop headers which *should* not be passed through the proxy.
#
# source://protocol-rack//lib/protocol/rack/response.rb#28
Protocol::Rack::Response::HOP_HEADERS = T.let(T.unsafe(nil), Array)

# Content-type driven input buffering, specific to the needs of `rack`.
#
# source://protocol-rack//lib/protocol/rack/rewindable.rb#12
class Protocol::Rack::Rewindable < ::Protocol::HTTP::Middleware
  # Initialize the rewindable middleware.
  #
  # @return [Rewindable] a new instance of Rewindable
  #
  # source://protocol-rack//lib/protocol/rack/rewindable.rb#25
  def initialize(app); end

  # Wrap the request body in a rewindable buffer if required.
  #
  # source://protocol-rack//lib/protocol/rack/rewindable.rb#53
  def call(request); end

  # source://protocol-rack//lib/protocol/rack/rewindable.rb#46
  def make_environment(request); end

  # Determine whether the request needs a rewindable body.
  #
  # @return [Boolean]
  #
  # source://protocol-rack//lib/protocol/rack/rewindable.rb#32
  def needs_rewind?(request); end
end

# Media types that require buffering.
#
# source://protocol-rack//lib/protocol/rack/rewindable.rb#14
Protocol::Rack::Rewindable::BUFFERED_MEDIA_TYPES = T.let(T.unsafe(nil), Regexp)

# source://protocol-rack//lib/protocol/rack/rewindable.rb#21
Protocol::Rack::Rewindable::POST = T.let(T.unsafe(nil), String)

# source://protocol-rack//lib/protocol/rack/version.rb#8
Protocol::Rack::VERSION = T.let(T.unsafe(nil), String)
